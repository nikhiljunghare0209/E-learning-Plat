// for to generate token we import library jsonwebtoken from  jwt package

import jwt from "jsonwebtoken";

// generateToken function takes three parameters:

// res: The response object from the Express.js framework.
// user: An object representing the authenticated user.
// message: A message to be sent in the JSON response.

export const generateToken = (res, user, message) => {

 // sign function in jwt package take userID ,secret key which we store here in .env file and expire duration.
  // sign functon used to generate token .JWT contain three parts 

//1) Payload: Contains the userID set to the user's _id.
//2) Secret Key: Retrieved from the environment variable SECRET_KEY, ensuring that the token can be verified later.
// 3)Options: Specifies that the token expires in 1 day ('1d'
// secret key is used to sign the token, ensuring its integrity and authenticity.
// The secret key should be kept confidential and not exposed to the client-side code.

// âœ… Why is the Secret Key Needed?
// The secret key is used to digitally sign the token so that:
// ðŸ” 1. Token can't be faked
// Anyone can create a JWT (it's just a Base64 string).
// But only someone with the correct secret key can sign it validly.
// Without the correct key, the token is invalid and will fail verification on backend.

// ðŸ”’ 2. It ensures authenticity
// When the server verifies the token later using jwt.verify(token, SECRET_KEY), it checks:
// Was this token really generated by us?
// Has it been tampered with?

// ðŸ›¡ï¸ 3. Prevents modification
// If someone tries to change the token (like change the userID), the signature becomes invalid and jwt.verify() will reject it.


// â— What Happens If You Don't Use a Secret Key?
// Anyone can create and send fake tokens to your server.
// Your backend would not know if a token is forged or valid.
// Major security risk â€” users can impersonate others.



  const token = jwt.sign({ userID: user._id }, process.env.SECRET_KEY, { expiresIn: '1d' });
  


  //Below Setting the Cookie: Uses the cookie method to set a cookie named "token" with the following options:

  // httpOnly: true: Ensures the cookie is accessible only by the web server, mitigating the risk of client-side scripts accessing it.
   
  // sameSite: 'strict': Prevents the browser from sending this cookie along with cross-site requests, enhancing CSRF protection.
  
  // maxAge: 24 * 60 * 60 * 1000: Sets the cookie's lifespan to 24 hours (24 hours Ã— 60 minutes/hour Ã— 60 seconds/minute Ã— 1000 milliseconds/second).
  return res
    .status(200)  //status(200) means request has succeeded
    .cookie("token", token, {
      httpOnly: true,
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000,
    })
    .json({
      success: true,  
      message,
      user,
    });
};



// EXPLAIN  [httpOnly: true] ->the HttpOnly attribute is a valuable security feature that helps protect cookies from being accessed or manipulated by client-side scripts, thereby mitigating risks associated with XSS attacks and enhancing the overall security of web applications.


// Server-Side Accessibility: Cookies marked with the HttpOnly attribute are designed to be sent only in HTTP(S) requests to the server. They are not accessible through client-side scripting languages like JavaScript. This means that even if an attacker manages to inject malicious scripts into a web page, they cannot access the contents of HttpOnly cookies. 


// Mitigation of XSS Attacks: XSS attacks often aim to steal sensitive information, such as session cookies, by exploiting vulnerabilities that allow the execution of malicious scripts within a user's browser. By marking cookies as HttpOnly, developers can prevent these scripts from accessing cookie data, thereby reducing the potential impact of such attacks



